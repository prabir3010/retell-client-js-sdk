import{EventEmitter as t}from"eventemitter3";import{Room as e,Track as i,RoomEvent as o,RemoteAudioTrack as a,createAudioAnalyser as n}from"livekit-client";const s=new TextDecoder;class r extends t{constructor(){super(),this.room=void 0,this.connected=!1,this.isAgentTalking=!1,this.analyzerComponent=void 0,this.captureAudioFrame=void 0,this.audioContext=void 0,this.audioTrackCounter=0,this.currentAudioPublication=void 0}async startCall(t){try{console.log("startCallConfig v1"),this.room=new e({audioCaptureDefaults:{autoGainControl:!0,echoCancellation:!0,noiseSuppression:!0,channelCount:1,deviceId:t.captureDeviceId,sampleRate:t.sampleRate},audioOutput:{deviceId:t.playbackDeviceId}}),this.handleRoomEvents(),this.handleAudioEvents(t),this.handleDataEvents(),await this.room.connect("wss://retell-ai-4ihahnq7.livekit.cloud",t.accessToken),console.log("connected to room",this.room.name),t.simulationMode?this.audioContext=new(window.AudioContext||window.webkitAudioContext)({sampleRate:24e3}):this.room.localParticipant.setMicrophoneEnabled(!0),this.connected=!0,this.emit("call_started")}catch(t){this.emit("error","Error starting call"),console.error("Error starting call",t),this.stopCall()}}async startAudioPlayback(){await this.room.startAudio()}stopCall(){var t;if(this.connected){if(this.connected=!1,this.emit("call_ended"),null==(t=this.room)||t.disconnect(),this.isAgentTalking=!1,delete this.room,this.analyzerComponent&&(this.analyzerComponent.cleanup(),delete this.analyzerComponent),this.captureAudioFrame&&(window.cancelAnimationFrame(this.captureAudioFrame),delete this.captureAudioFrame),this.currentAudioPublication){try{this.room.localParticipant.unpublishTrack(this.currentAudioPublication.track)}catch(t){console.warn("Error unpublishing track on stopCall",t)}delete this.currentAudioPublication}this.audioContext&&"closed"!==this.audioContext.state&&(this.audioContext.close(),delete this.audioContext),this.audioTrackCounter=0}}mute(){this.connected&&this.room.localParticipant.setMicrophoneEnabled(!1)}unmute(){this.connected&&this.room.localParticipant.setMicrophoneEnabled(!0)}async sendAudioBuffer(t){if(!this.connected)throw new Error("Cannot send audio buffer: not connected to call");if(!this.audioContext)throw new Error("AudioContext not initialized. Make sure to set simulationMode: true in startCall()");try{if(this.currentAudioPublication){try{await this.room.localParticipant.unpublishTrack(this.currentAudioPublication.track),console.log("Unpublished previous audio track")}catch(t){console.warn("Error unpublishing previous track",t)}this.currentAudioPublication=void 0}"suspended"===this.audioContext.state&&await this.audioContext.resume(),console.log(`Starting progressive audio streaming (${t.duration.toFixed(2)}s)`);const e=this.audioContext.createMediaStreamDestination(),o=e.stream.getAudioTracks()[0];if(!o)throw new Error("Failed to create audio track");const a="simulated_audio_"+this.audioTrackCounter++,n=await this.room.localParticipant.publishTrack(o,{name:a,source:i.Source.Microphone});this.currentAudioPublication=n,console.log(`Published progressive audio track (${a})`),await new Promise(t=>setTimeout(t,200)),await this.sendAudioProgressively(t,e),e.disconnect(),o.stop(),console.log("Progressive audio streaming completed")}catch(t){throw console.error("Error sending audio buffer",t),t}}async sendAudioProgressively(t,e){const i=t.sampleRate,o=t.getChannelData(0),a=Math.floor(20*i/1e3),n=o.length,s=Math.ceil(n/a);console.log(`  Sending ${s} chunks (20ms each)...`);let r=0;const c=this.audioContext.currentTime;for(let t=0;t<s;t++){const s=Math.min(a,n-r),l=this.audioContext.createBuffer(1,s,i),d=l.getChannelData(0);for(let t=0;t<s;t++)d[t]=o[r+t];const u=this.audioContext.createBufferSource();u.buffer=l,u.connect(e),u.start(c+20*t/1e3),r+=s,await new Promise(t=>setTimeout(t,20))}const l=(n%a||a)/i*1e3;await new Promise(t=>setTimeout(t,l+100))}captureAudioSamples(){if(!this.connected||!this.analyzerComponent)return;let t=new Float32Array(this.analyzerComponent.analyser.fftSize);this.analyzerComponent.analyser.getFloatTimeDomainData(t),this.emit("audio",t),this.captureAudioFrame=window.requestAnimationFrame(()=>this.captureAudioSamples())}handleRoomEvents(){this.room.on(o.ParticipantDisconnected,t=>{"server"===(null==t?void 0:t.identity)&&setTimeout(()=>{this.stopCall()},500)}),this.room.on(o.Disconnected,()=>{this.stopCall()})}handleAudioEvents(t){this.room.on(o.TrackSubscribed,(e,o,s)=>{e.kind===i.Kind.Audio&&e instanceof a&&("agent_audio"===o.trackName&&(this.emit("call_ready"),t.emitRawAudioSamples&&(this.analyzerComponent=n(e),this.captureAudioFrame=window.requestAnimationFrame(()=>this.captureAudioSamples()))),e.attach())})}handleDataEvents(){this.room.on(o.DataReceived,(t,e,i,o)=>{try{if("server"!==(null==e?void 0:e.identity))return;let i=s.decode(t),o=JSON.parse(i);"update"===o.event_type?this.emit("update",o):"metadata"===o.event_type?this.emit("metadata",o):"agent_start_talking"===o.event_type?(this.isAgentTalking=!0,this.emit("agent_start_talking")):"agent_stop_talking"===o.event_type?(this.isAgentTalking=!1,this.emit("agent_stop_talking")):"node_transition"===o.event_type&&this.emit("node_transition",o)}catch(t){console.error("Error decoding data received",t)}})}}export{r as RetellWebClient};
