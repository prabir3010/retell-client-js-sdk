import{EventEmitter as t}from"eventemitter3";import{Room as e,Track as o,RoomEvent as i,RemoteAudioTrack as n,createAudioAnalyser as a}from"livekit-client";const r=new TextDecoder;class s extends t{constructor(){super(),this.room=void 0,this.connected=!1,this.isAgentTalking=!1,this.analyzerComponent=void 0,this.captureAudioFrame=void 0,this.audioContext=void 0,this.audioTrackCounter=0,this.currentAudioPublication=void 0}async startCall(t){try{console.log("startCallConfig v1"),this.room=new e({audioCaptureDefaults:{autoGainControl:!0,echoCancellation:!0,noiseSuppression:!0,channelCount:1,deviceId:t.captureDeviceId,sampleRate:t.sampleRate},audioOutput:{deviceId:t.playbackDeviceId}}),this.handleRoomEvents(),this.handleAudioEvents(t),this.handleDataEvents(),await this.room.connect("wss://retell-ai-4ihahnq7.livekit.cloud",t.accessToken),console.log("connected to room",this.room.name),t.simulationMode?this.audioContext=new(window.AudioContext||window.webkitAudioContext)({sampleRate:24e3}):this.room.localParticipant.setMicrophoneEnabled(!0),this.connected=!0,this.emit("call_started")}catch(t){this.emit("error","Error starting call"),console.error("Error starting call",t),this.stopCall()}}async startAudioPlayback(){await this.room.startAudio()}stopCall(){var t;if(this.connected){if(this.connected=!1,this.emit("call_ended"),null==(t=this.room)||t.disconnect(),this.isAgentTalking=!1,delete this.room,this.analyzerComponent&&(this.analyzerComponent.cleanup(),delete this.analyzerComponent),this.captureAudioFrame&&(window.cancelAnimationFrame(this.captureAudioFrame),delete this.captureAudioFrame),this.currentAudioPublication){try{this.room.localParticipant.unpublishTrack(this.currentAudioPublication.track)}catch(t){console.warn("Error unpublishing track on stopCall",t)}delete this.currentAudioPublication}this.audioContext&&"closed"!==this.audioContext.state&&(this.audioContext.close(),delete this.audioContext),this.audioTrackCounter=0}}mute(){this.connected&&this.room.localParticipant.setMicrophoneEnabled(!1)}unmute(){this.connected&&this.room.localParticipant.setMicrophoneEnabled(!0)}async sendAudioBuffer(t){if(!this.connected)throw new Error("Cannot send audio buffer: not connected to call");if(!this.audioContext)throw new Error("AudioContext not initialized. Make sure to set simulationMode: true in startCall()");try{if(this.currentAudioPublication){try{await this.room.localParticipant.unpublishTrack(this.currentAudioPublication.track),console.log("Unpublished previous audio track")}catch(t){console.warn("Error unpublishing previous track",t)}this.currentAudioPublication=void 0}"suspended"===this.audioContext.state&&await this.audioContext.resume();const e=this.audioContext.createBufferSource();e.buffer=t;const i=this.audioContext.createMediaStreamDestination();e.connect(i);const n=i.stream.getAudioTracks()[0];if(!n)throw new Error("Failed to create audio track from buffer");const a="simulated_audio_"+this.audioTrackCounter++,r=await this.room.localParticipant.publishTrack(n,{name:a,source:o.Source.Microphone});return this.currentAudioPublication=r,console.log(`Publishing audio buffer to call (${a})`),await new Promise(t=>setTimeout(t,100)),e.start(0),new Promise((o,a)=>{let r=null,s=!1;const c=async function(t=!1){if(!s){s=!0,null!==r&&(clearTimeout(r),r=null);try{e.disconnect(),i.disconnect(),n.stop(),t?a(new Error("Audio buffer playback timeout")):(console.log("Audio buffer playback completed"),o())}catch(t){console.error("Error cleaning up audio buffer",t),a(t)}}};e.onended=()=>c(!1),r=window.setTimeout(()=>{console.warn("Audio buffer playback timeout"),c(!0)},1e3*(t.duration+5))})}catch(t){throw console.error("Error sending audio buffer",t),t}}captureAudioSamples(){if(!this.connected||!this.analyzerComponent)return;let t=new Float32Array(this.analyzerComponent.analyser.fftSize);this.analyzerComponent.analyser.getFloatTimeDomainData(t),this.emit("audio",t),this.captureAudioFrame=window.requestAnimationFrame(()=>this.captureAudioSamples())}handleRoomEvents(){this.room.on(i.ParticipantDisconnected,t=>{"server"===(null==t?void 0:t.identity)&&setTimeout(()=>{this.stopCall()},500)}),this.room.on(i.Disconnected,()=>{this.stopCall()})}handleAudioEvents(t){this.room.on(i.TrackSubscribed,(e,i,r)=>{e.kind===o.Kind.Audio&&e instanceof n&&("agent_audio"===i.trackName&&(this.emit("call_ready"),t.emitRawAudioSamples&&(this.analyzerComponent=a(e),this.captureAudioFrame=window.requestAnimationFrame(()=>this.captureAudioSamples()))),e.attach())})}handleDataEvents(){this.room.on(i.DataReceived,(t,e,o,i)=>{try{if("server"!==(null==e?void 0:e.identity))return;let o=r.decode(t),i=JSON.parse(o);"update"===i.event_type?this.emit("update",i):"metadata"===i.event_type?this.emit("metadata",i):"agent_start_talking"===i.event_type?(this.isAgentTalking=!0,this.emit("agent_start_talking")):"agent_stop_talking"===i.event_type?(this.isAgentTalking=!1,this.emit("agent_stop_talking")):"node_transition"===i.event_type&&this.emit("node_transition",i)}catch(t){console.error("Error decoding data received",t)}})}}export{s as RetellWebClient};
